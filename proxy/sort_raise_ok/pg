Flat profile:

Each sample counts as 0.01 seconds.
 no time accumulated

  %   cumulative   self              self     total           
 time   seconds   seconds    calls  Ts/call  Ts/call  name    
  0.00      0.00     0.00     1200     0.00     0.00  get_index_by_code_ascii
  0.00      0.00     0.00      300     0.00     0.00  find_location
  0.00      0.00     0.00      300     0.00     0.00  sort_add
  0.00      0.00     0.00      100     0.00     0.00  do_stock
  0.00      0.00     0.00      100     0.00     0.00  find_entity_by_key
  0.00      0.00     0.00      100     0.00     0.00  save_key
  0.00      0.00     0.00        3     0.00     0.00  parse
  0.00      0.00     0.00        2     0.00     0.00  jim_malloc
  0.00      0.00     0.00        2     0.00     0.00  send_heart
  0.00      0.00     0.00        1     0.00     0.00  get_market
  0.00      0.00     0.00        1     0.00     0.00  init_login
  0.00      0.00     0.00        1     0.00     0.00  init_market
  0.00      0.00     0.00        1     0.00     0.00  init_socket
  0.00      0.00     0.00        1     0.00     0.00  init_sort_area
  0.00      0.00     0.00        1     0.00     0.00  parse_realtime
  0.00      0.00     0.00        1     0.00     0.00  send_auto_push
  0.00      0.00     0.00        1     0.00     0.00  send_realtime
  0.00      0.00     0.00        1     0.00     0.00  unpack

			Call graph


granularity: each sample hit covers 4 byte(s) no time propagated

index % time    self  children    called     name
                0.00    0.00     600/1200        save_key [6]
                0.00    0.00     600/1200        find_entity_by_key [5]
[1]      0.0    0.00    0.00    1200         get_index_by_code_ascii [1]
-----------------------------------------------
                0.00    0.00     300/300         sort_add [3]
[2]      0.0    0.00    0.00     300         find_location [2]
-----------------------------------------------
                0.00    0.00     300/300         do_stock [4]
[3]      0.0    0.00    0.00     300         sort_add [3]
                0.00    0.00     300/300         find_location [2]
-----------------------------------------------
                0.00    0.00     100/100         parse_realtime [15]
[4]      0.0    0.00    0.00     100         do_stock [4]
                0.00    0.00     300/300         sort_add [3]
                0.00    0.00     100/100         find_entity_by_key [5]
-----------------------------------------------
                0.00    0.00     100/100         do_stock [4]
[5]      0.0    0.00    0.00     100         find_entity_by_key [5]
                0.00    0.00     600/1200        get_index_by_code_ascii [1]
-----------------------------------------------
                0.00    0.00     100/100         get_market [10]
[6]      0.0    0.00    0.00     100         save_key [6]
                0.00    0.00     600/1200        get_index_by_code_ascii [1]
-----------------------------------------------
                                   1             parse [7]
                0.00    0.00       3/3           init_receive [28]
[7]      0.0    0.00    0.00       3+1       parse [7]
                0.00    0.00       1/1           parse_realtime [15]
                0.00    0.00       1/1           send_auto_push [16]
                0.00    0.00       1/1           unpack [18]
                                   1             parse [7]
-----------------------------------------------
                0.00    0.00       1/2           send_auto_push [16]
                0.00    0.00       1/2           get_market [10]
[8]      0.0    0.00    0.00       2         jim_malloc [8]
-----------------------------------------------
                0.00    0.00       2/2           main [30]
[9]      0.0    0.00    0.00       2         send_heart [9]
-----------------------------------------------
                0.00    0.00       1/1           init_market [12]
[10]     0.0    0.00    0.00       1         get_market [10]
                0.00    0.00     100/100         save_key [6]
                0.00    0.00       1/2           jim_malloc [8]
                0.00    0.00       1/1           init_sort_area [14]
-----------------------------------------------
                0.00    0.00       1/1           main [30]
[11]     0.0    0.00    0.00       1         init_login [11]
-----------------------------------------------
                0.00    0.00       1/1           main [30]
[12]     0.0    0.00    0.00       1         init_market [12]
                0.00    0.00       1/1           get_market [10]
-----------------------------------------------
                0.00    0.00       1/1           main [30]
[13]     0.0    0.00    0.00       1         init_socket [13]
-----------------------------------------------
                0.00    0.00       1/1           get_market [10]
[14]     0.0    0.00    0.00       1         init_sort_area [14]
-----------------------------------------------
                0.00    0.00       1/1           parse [7]
[15]     0.0    0.00    0.00       1         parse_realtime [15]
                0.00    0.00     100/100         do_stock [4]
-----------------------------------------------
                0.00    0.00       1/1           parse [7]
[16]     0.0    0.00    0.00       1         send_auto_push [16]
                0.00    0.00       1/2           jim_malloc [8]
-----------------------------------------------
                0.00    0.00       1/1           main [30]
[17]     0.0    0.00    0.00       1         send_realtime [17]
-----------------------------------------------
                0.00    0.00       1/1           parse [7]
[18]     0.0    0.00    0.00       1         unpack [18]
-----------------------------------------------

Index by function name

   [4] do_stock (main.c)      [12] init_market             [6] save_key
   [5] find_entity_by_key     [13] init_socket            [16] send_auto_push
   [2] find_location (sort.c) [14] init_sort_area          [9] send_heart
   [1] get_index_by_code_ascii [8] jim_malloc             [17] send_realtime
  [10] get_market              [7] parse                   [3] sort_add
  [11] init_login (main.c)    [15] parse_realtime         [18] unpack

*** File /home/jim/source_code/data-api/proxy/sort_raise_ok/help.c:
                #include<stdio.h>
                #include "config.h"
                
           2 -> int jim_malloc(int size, void ** out){
                  int page_size = 0;
                  unsigned int length = 0;
                  page_size = ceil(size / 4);
                  length = page_size * 4;
                  //  if(length == size) length = (page_size+1)*4;
                  *out = (void *)malloc(size);
                  if(*out == NULL){
                    printf("malloc error!\n");
                    return -1;
                  }
                  memset(*out, 0x00, size);
                  return 0;
       ##### -> }


Top 10 Lines:

     Line      Count

        4          2

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line


*** File /home/jim/source_code/data-api/proxy/sort_raise_ok/market.c:
                #include "market.h"
                #include "assert.h"
                #include <stdlib.h>
                #include <stdio.h>
                #include <string.h>
                #define DATA_FILE "./txt/my_data"
                
                my_key_t key_root = {0};
                extern market_t market_list[];
                
                //get code for both market
           1 -> int init_market(){
                  char * data_file_name = DATA_FILE;
                  FILE * fp = fopen(data_file_name, "r");
                
                  int size = 0;
                  int index = 0;
                  if(fp == 0){
                    DEBUG("error:[%s]","read my_data err!");
                    return -1;
                  }
                  fseek(fp, 0L, SEEK_END);
                  size = ftell(fp)/14;
                  if(size == 0){
                    DEBUG("error[%s]", "get file size err!");
                    return -1;
                  }
                  fseek(fp, 0L, SEEK_SET);
                  //stock
                  //size = 3050;
                  size = 100;
                  get_market(index, fp, size);
                  close(fp);
                  return 0;
                }
                
                int get_market(int index, FILE * fp, int size)
           1 -> {
                  entity_t * entity;
                  int entity_list_len = 0;
                  char buff[14];
                  int ret = -1;
                
                  market_list[index].entity_list_size = size;
                  //market_list[index].entity_list_size = 12;
                  if(market_list[index].list != NULL){free(market_list[index].list);}
                  //init list
                  ret = jim_malloc(market_list[index].entity_list_size*sizeof(entity_t), &market_list[index].list);
                  assert(ret == 0);
                
                  int i = 0;
                  entity = market_list[index].list;
                  int * yestoday_max_price = &market_list[index].yestoday_max;
                  int * yestoday_min_price = &market_list[index].yestoday_min;
                  *yestoday_min_price      = 100000;
                  char * code = NULL;
                  unsigned short code_type = 0;
                  int max = 0;
                  char *c = NULL;
                  for(; i< market_list[index].entity_list_size; i++){
                    memset(&buff, 0x00, 14);
                    //if(max >12) break;
                    c = fread(buff, sizeof(unsigned char), 14, fp);
                    if(c == 0){
                      DEBUG("error[%s]", "read err!");
                      return -1;
                    }
                    entity->type = *(int*)buff;
                    //strcpy(entity->code, cJSON_GetObjectItem(item, "code")->valuestring);
                    strncpy(entity->code, buff+8, 6);
                    entity->code[6] = '\0';
                    entity->pre_close = *(int*)(buff+4);
                    //find max and min of price
                    if(entity->pre_close != 0){
                      if(*yestoday_max_price < entity->pre_close){ *yestoday_max_price = entity->pre_close;}
                      if(*yestoday_min_price > entity->pre_close){ *yestoday_min_price = entity->pre_close;}
                    }
                
                    DEBUG("info:[index:%d\tcode:%s\tpreclose:%d]",
                	   i,
                	   entity->code,
                	   entity->pre_close);
                    //save to key
                    switch(entity->type){
                    case 0x1101:{
                      assert(save_key(entity->code, 6, 0, entity) == 0);
                    }break;
                    case 0x1201:{
                      assert(save_key(entity->code, 6, 1, entity) == 0);
                    }break;
                    case 0x1206:{
                      assert(save_key(entity->code, 6, 2, entity) == 0);
                    }break;
                    case 0x120b:{
                      assert(save_key(entity->code, 6, 3, entity) == 0);
                    }break;
                    }
                
                    entity ++;
                    //item_sort_price ++;
                    //item_sort_raise ++;
                    max ++;
                  }
                
                  DEBUG("info:[yestoday_max:%d\tyestoday_min:%d]", *yestoday_max_price, *yestoday_min_price);
                  //set setting_price
                  market_list[index].setting_max = market_list[index].yestoday_max * 1.1;
                  market_list[index].setting_min = market_list[index].yestoday_min * 0.9;
                
                  //init sort area
                  init_sort_area(&market_list[index]);
                
                  DEBUG("info:[date:%s\tcode_type:%x\tunit:%d\topen_close_time:%s\tcode_size:%d]",
                	 market_list[index].date,
                	 market_list[index].code_type,
                	 market_list[index].unit,
                	 market_list[index].open_close_time,
                	 market_list[index].entity_list_size);
                
                  return 0;
                }
                
                /**
                   from first letter to last,every letter point floor
                */
                int save_key(char * code, unsigned code_len, int code_type_index, entity_t * entity)
         100 -> {
                  int i              = 0;
                  char ascii         = 0;
                  int unit           = 0;
                  my_key_t * cur_key = &key_root;
                  my_key_t * tmp_key = NULL;;
                  void * last_key    = NULL;
                  int location       = 0;
                
                  for(i=0; i<6; i++){
                    ascii = *(code+i);
                    location = get_index_by_code_ascii(ascii);
                    //check location is malloc
                    if(cur_key->childs[location] == NULL){
                      tmp_key = (my_key_t *)malloc(sizeof(my_key_t));
                      if(tmp_key == NULL){
                	DEBUG("error:[%s]","malloc error!");
                	exit(-1);
                      }
                      memset(tmp_key, 0x00, sizeof(my_key_t));
                      tmp_key->floor = i+1;
                      cur_key->childs[location] = tmp_key;
                      cur_key = tmp_key;
                    }
                    else{
                      cur_key = cur_key->childs[location];
                    }
                  }
                  //code_type node
                  //save entity of point
                  if(cur_key != NULL && cur_key->childs[code_type_index] == NULL){
                    cur_key->childs[code_type_index] = entity;
                  }
                
                  return 0;
                }
                
                void * find_entity_by_key(char * code, unsigned int code_len, int code_type_index)
         100 -> {
                  int location = 0;
                  char ascii   = 0;
                  int i        = 0;
                  void * address  = NULL;
                  my_key_t * cur_key = &key_root;
                
                  //from first to sixth bit
                  for(i=0; i<6; i++){
                    ascii = *(code+i);
                    location = get_index_by_code_ascii(ascii);
                    cur_key = cur_key->childs[location];
                  }
                
                  //7th bit
                  location = code_type_index;
                  address = cur_key->childs[location];
                
                  return address;
       ##### -> }


Top 10 Lines:

     Line      Count

      127        100
      165        100
       12          1
       38          1

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

      202   Total number of line executions
    40.40   Average executions per line


*** File /home/jim/source_code/data-api/proxy/sort_raise_ok/sort.c:
                #include "config.h"
                #include "sort.h"
                #include "market.h"
                #include <assert.h>
                #include <stdbool.h>
                #include <math.h>
                
                static int sort_area(market_t * my_market, column_n column);
                static int find_location(market_t * my_market, entity_t * entity, column_n column, int * area_index, int * queue_index);
                static int remove_entity(market_t * my_market, entity_t * entity, column_n column);
                extern market_t market_list[];
                
                //init area and queueof area
                //malloc queue and setting area value
                int init_sort_area(my_market)
                     market_t * my_market;
           1 -> {
                  int i = 0;
                  sort_area_t * price_sort_area = NULL;
                  sort_area_t * raise_sort_area = NULL;
                  sort_area_t * range_sort_area = NULL;
                  int price_step_len = 0;
                  int raise_step_len = 0;
                  int range_step_len = 0.0;
                  //char tmp_range[6] = {0};
                  price_step_len = (my_market->setting_max - my_market->setting_min)/AREA_NUMBER;
                  raise_step_len = (my_market->yestoday_max *0.1*2)/AREA_NUMBER;
                  //range_step_len = ceilf(0.4 * 10000/AREA_NUMBER)/10000;
                  //snprintf(tmp_range, "%.4f", (float)(0.4/AREA_NUMBER), 6);
                  //range_step_len = (float)atoll(tmp_range);
                  range_step_len = 4000/AREA_NUMBER;
                  //range_step_len = ( (float)( (int)( (range_step_len+0.005)*100 ) ) )/100;
                  //range_step_len = ceilf(37.777779*100)/100;
                  int raise_min = (-1)*(my_market->yestoday_max * 0.1);
                  float range_min = -2000;
                  int price_area_queue_len = 0;
                  int raise_area_queue_len = 0;
                  int range_area_queue_len = 0;
                  int default_area_queue_len = AREA_NUMBER*AREA_QUEUE_DEFAULT_LEN*sizeof(sort_area_queue_t);
                  int price_page_size = 0;
                  int raise_page_size = 0;
                  int range_page_size = 0;
                  price_page_size = default_area_queue_len;
                  raise_page_size = default_area_queue_len;
                  range_page_size = default_area_queue_len;
                  //price_page_size = ceil(1.0*default_area_queue_len/PAGE_SIZE);
                  //raise_page_size = ceil(1.0*default_area_queue_len/PAGE_SIZE);
                  //price_area_queue_len = price_page_size * PAGE_SIZE;
                  //raise_area_queue_len = raise_page_size * PAGE_SIZE;
                  price_area_queue_len = price_page_size;
                  raise_area_queue_len = raise_page_size;
                  range_area_queue_len = range_page_size;
                  sort_area_queue_t * price_base_queue = (char *)malloc(price_area_queue_len);
                  sort_area_queue_t * raise_base_queue = (char *)malloc(raise_area_queue_len);
                  sort_area_queue_t * range_base_queue = (char *)malloc(range_area_queue_len);
                  if(price_base_queue == NULL){
                    DEBUG("error:[%s]", "malloc error!");
                    return -1;
                  }
                  memset(price_base_queue, 0x00, price_area_queue_len);
                  if(raise_base_queue == NULL){
                    DEBUG("error:[%s]", "malloc error!");
                    return -1;
                  }
                  memset(raise_base_queue, 0x00, raise_area_queue_len);
                  if(range_base_queue == NULL){
                    DEBUG("error:[%s]", "malloc error!");
                    return -1;
                  }
                  memset(range_base_queue, 0x00, range_area_queue_len);
                
                  price_sort_area = &my_market->sort_area_price;
                  raise_sort_area = &my_market->sort_area_raise;
                  range_sort_area = &my_market->sort_area_range;
                  for(; i< AREA_NUMBER; i++){
                    price_sort_area->cur = price_base_queue + AREA_QUEUE_DEFAULT_LEN * i;
                    raise_sort_area->cur = raise_base_queue + AREA_QUEUE_DEFAULT_LEN * i;
                    range_sort_area->cur = range_base_queue + AREA_QUEUE_DEFAULT_LEN * i;
                
                    price_sort_area->min_value.ivalue = my_market->setting_min + price_step_len * i;
                    price_sort_area->max_value.ivalue = price_sort_area->min_value.ivalue + price_step_len +1;
                    raise_sort_area->min_value.ivalue = raise_min + raise_step_len * i;
                    raise_sort_area->max_value.ivalue = raise_sort_area->min_value.ivalue + raise_step_len + 1;
                    range_sort_area->min_value.ivalue = range_min + range_step_len * i;
                    range_sort_area->max_value.ivalue = range_sort_area->min_value.ivalue + range_step_len + 1;
                
                    price_sort_area->real_size  = 0;
                    raise_sort_area->real_size  = 0;
                    range_sort_area->real_size  = 0;
                    price_sort_area->allow_size = AREA_QUEUE_DEFAULT_LEN;
                    raise_sort_area->allow_size = AREA_QUEUE_DEFAULT_LEN;
                    range_sort_area->allow_size = AREA_QUEUE_DEFAULT_LEN;
                
                    price_sort_area ++;
                    raise_sort_area ++;
                    range_sort_area ++;
                  }
                  return 0;
                }
                
                //from samll to big
                int my_sort(my_market, column)
                  market_t * my_market;
                  column_n column;
       ##### -> {
                  //sort_list(code_type_index, column);
                  sort_area(my_market, column);
                
                  return 0;
                }
                
                int sort_add(my_market, entity, column)
                     market_t * my_market;
                     entity_t * entity;
                     column_n column;
         300 -> {
                  int i = 0;
                  int area_index = 0;
                  int queue_index = 0;
                  sort_area_t * cur_area = NULL;
                  sort_area_queue_t * cur_queue = NULL, * pre_queue = NULL;
                  int ret = -1;
                
                  //find entity from area
                  ret = find_location(my_market, entity, column, &area_index, &queue_index);
                  assert(ret == 0);
                  switch(column){
                  case NEW_PRICE:{
                    entity->price_area[0] = area_index;
                    entity->price_area[1] = queue_index;
                  }break;
                  case RAISE:{
                    entity->raise_area[0] = area_index;
                    entity->raise_area[1] = queue_index;
                  }break;
                  case RANGE:{
                    entity->range_area[0] = area_index;
                    entity->range_area[1] = queue_index;
                  }break;
                  default:{
                
                  }
                  }
                  //check is exits,by pre_*
                  switch(column){
                  case NEW_PRICE:{
                    cur_area = &my_market->sort_area_price[area_index];
                
                    if(queue_index == 0){//first
                      if(cur_area->real_size == 0){
                	cur_queue = cur_area->cur;
                	cur_queue->index = 0;
                	cur_queue->entity = entity;
                	cur_queue->entity->price_area[1] = cur_queue->index;
                      }
                      else{
                	i = cur_area->real_size;
                	pre_queue = cur_area->cur + i -1;
                	cur_queue = cur_area->cur + i;
                	for(; i>queue_index; i--){
                	  cur_queue->index = pre_queue->index+1;
                	  cur_queue->entity = pre_queue->entity;
                	  cur_queue->entity->price_area[1] = cur_queue->index;
                	  cur_queue --;
                	  pre_queue --;
                	}
                	cur_queue = cur_area->cur + queue_index;
                	cur_queue->entity = entity;
                	cur_queue->index = queue_index;
                	cur_queue->entity->price_area[1] = cur_queue->index;
                      }
                    }
                    else if(queue_index == cur_area->real_size){//last
                      cur_queue = cur_area->cur + queue_index;
                      cur_queue->entity = entity;
                      cur_queue->index = queue_index;
                      cur_queue->entity->price_area[1] = queue_index;
                    }
                    else if(queue_index < cur_area->real_size){//in btween real_size
                      //move
                      i = cur_area->real_size;
                      pre_queue = cur_area->cur + i -1;
                      cur_queue = cur_area->cur + i;
                      for(; i>queue_index; i--){
                	cur_queue->index = pre_queue->index+1;
                	cur_queue->entity = pre_queue->entity;
                	cur_queue->entity->price_area[1] = cur_queue->index;
                	cur_queue --;
                	pre_queue --;
                      }
                      cur_queue = cur_area->cur + queue_index;
                      cur_queue->entity = entity;
                      cur_queue->index = queue_index;
                      cur_queue->entity->price_area[1] = cur_queue->index;
                    }
                    else{//not enough and remalloc
                      cur_queue = cur_area->cur + queue_index;
                      cur_queue->index = queue_index;
                      cur_queue->entity = entity;
                      cur_queue->entity->price_area[1] = cur_queue->index;
                    }
                
                    cur_area->real_size ++;
                  }break;
                  case RAISE:{
                    cur_area = &my_market->sort_area_raise[area_index];
                
                    if(queue_index == 0){//first
                      if(cur_area->real_size == 0){
                	cur_queue = cur_area->cur;
                	cur_queue->index = 0;
                	cur_queue->entity = entity;
                	cur_queue->entity->raise_area[1] = cur_queue->index;
                      }
                      else{
                	i = cur_area->real_size;
                	pre_queue = cur_area->cur + i -1;
                	cur_queue = cur_area->cur + i;
                	for(; i>queue_index; i--){
                	  cur_queue->index = pre_queue->index+1;
                	  cur_queue->entity = pre_queue->entity;
                	  cur_queue->entity->raise_area[1] = cur_queue->index;
                	  cur_queue --;
                	  pre_queue --;
                	}
                	cur_queue = cur_area->cur + queue_index;
                	cur_queue->entity = entity;
                	cur_queue->index = queue_index;
                	cur_queue->entity->raise_area[1] = cur_queue->index;
                      }
                    }
                    else if(queue_index == cur_area->real_size){//last
                      cur_queue = cur_area->cur + queue_index;
                      cur_queue->entity = entity;
                      cur_queue->index = queue_index;
                      cur_queue->entity->raise_area[1] = queue_index;
                    }
                    else if(queue_index < cur_area->real_size){//in btween real_size
                      //move
                      i = cur_area->real_size;
                      pre_queue = cur_area->cur + i -1;
                      cur_queue = cur_area->cur + i;
                      for(; i>queue_index; i--){
                	cur_queue->index = pre_queue->index+1;
                	cur_queue->entity = pre_queue->entity;
                	cur_queue->entity->raise_area[1] = cur_queue->index;
                	cur_queue --;
                	pre_queue --;
                      }
                      cur_queue = cur_area->cur + queue_index;
                      cur_queue->entity = entity;
                      cur_queue->index = queue_index;
                      cur_queue->entity->raise_area[1] = cur_queue->index;
                    }
                    else{//not enough and remalloc
                      cur_queue = cur_area->cur + queue_index;
                      cur_queue->index = queue_index;
                      cur_queue->entity = entity;
                      cur_queue->entity->raise_area[1] = cur_queue->index;
                    }
                    cur_area->real_size ++;
                  }break;
                  case RANGE:{
                    cur_area = &my_market->sort_area_range[area_index];
                    if(queue_index == 0){//first
                      if(cur_area->real_size == 0){
                	cur_queue = cur_area->cur;
                	cur_queue->index = 0;
                	cur_queue->entity = entity;
                	cur_queue->entity->range_area[1] = cur_queue->index;
                      }else{
                	i = cur_area->real_size;
                	pre_queue = cur_area->cur + i -1;
                	cur_queue = cur_area->cur + i;
                	for(; i>queue_index; i--){
                	  cur_queue->index = pre_queue->index+1;
                	  cur_queue->entity = pre_queue->entity;
                	  cur_queue->entity->range_area[1] = cur_queue->index;
                	  cur_queue --;
                	  pre_queue --;
                	}
                	cur_queue = cur_area->cur + queue_index;
                	cur_queue->entity = entity;
                	cur_queue->index = queue_index;
                	cur_queue->entity->range_area[1] = cur_queue->index;
                      }
                    }else if(queue_index == cur_area->real_size){//last
                      cur_queue = cur_area->cur + queue_index;
                      cur_queue->entity = entity;
                      cur_queue->index = queue_index;
                      cur_queue->entity->range_area[1] = queue_index;
                    }else if(queue_index < cur_area->real_size){//in btween real_size
                      //move
                      i = cur_area->real_size;
                      pre_queue = cur_area->cur + i -1;
                      cur_queue = cur_area->cur + i;
                      for(; i>queue_index; i--){
                	cur_queue->index = pre_queue->index+1;
                	cur_queue->entity = pre_queue->entity;
                	cur_queue->entity->range_area[1] = cur_queue->index;
                	cur_queue --;
                	pre_queue --;
                      }
                      cur_queue = cur_area->cur + queue_index;
                      cur_queue->entity = entity;
                      cur_queue->index = queue_index;
                      cur_queue->entity->range_area[1] = cur_queue->index;
                    }else{//not enough and remalloc
                      cur_queue = cur_area->cur + queue_index;
                      cur_queue->index = queue_index;
                      cur_queue->entity = entity;
                      cur_queue->entity->range_area[1] = cur_queue->index;
                    }
                    cur_area->real_size ++;
                  }break;
                  default:{
                
                  }break;
                  }
                
                  return 0;
                }
                
                int sort_update(my_market, entity, column)
                     market_t * my_market;
                     entity_t * entity;
                     column_n column;
       ##### -> {
                  //remove
                  remove_entity(my_market, entity, column);
                  //add
                  sort_add(my_market, entity, column);
                
                  return 0;
                }
                
                //find area and queue by entity
                static int find_location(my_market, entity, column, area_index, queue_index)
                     market_t * my_market;
                     entity_t * entity;
                     column_n column;
                     int * area_index;
                     int * queue_index;
         300 -> {
                  int i = 0;
                  sort_area_t * area = NULL;
                  sort_area_t * pre_area = NULL;
                  int tmp_ivalue = 0;
                  switch(column){
                  case NEW_PRICE:
                    area = &my_market->sort_area_price;
                    break;
                  case RAISE:
                    area = &my_market->sort_area_raise;
                    break;
                  case RANGE:
                    area = &my_market->sort_area_range;
                    break;
                  default:
                    break;
                  }
                  sort_area_queue_t * queue = NULL;
                  int real_size = 0;
                  value_t value;
                  entity_t * item = NULL;
                  sort_area_queue_t * tmp_queue = NULL;
                
                  switch(column){
                  case NEW_PRICE:{
                    value.ivalue = entity->price;
                  }break;
                  case RAISE:{
                    value.ivalue = entity->raise;
                  }break;
                  case RANGE:{
                    value.ivalue = entity->range;
                  }break;
                  default:{
                
                  }break;
                  }
                
                  pre_area = area;
                  //find area
                  for(; i<AREA_NUMBER; i++){
                    if(value.ivalue > area->max_value.ivalue){
                      pre_area = area;
                      area ++;
                      continue;
                    }
                
                    *area_index = i;
                    real_size = area->real_size;
                    queue = area->cur;
                    break;
                  }
                  if(i == AREA_NUMBER){
                    area = pre_area;
                    i = AREA_NUMBER -1;
                    *area_index = i;
                    real_size = area->real_size;
                    queue = area->cur;
                  }
                  //find queue
                  if(area->real_size == 0){
                    *queue_index = 0;
                  }
                  else{
                    if(area->real_size< area->allow_size){//enough
                      //i = real_size/2;
                      //queue = queue+i;
                      //      *queue_index = search_queue_index(value.ivalue, 0, real_size, queue, column);
                      for(i=0; i < real_size; i++){
                	item = queue->entity;
                	switch(column){
                	case NEW_PRICE:{
                	  tmp_ivalue = item->price;
                	  if(value.ivalue > tmp_ivalue){
                	    queue++;
                	    continue;
                	  }else{
                	    *queue_index = i;
                	    return 0;
                	  }
                	}break;
                	case RAISE:{
                	  tmp_ivalue = item->raise;
                	  if(value.ivalue > tmp_ivalue){
                	    queue++;
                	    continue;
                	  }else{
                	    *queue_index = i;
                	    return 0;
                	  }
                	}break;
                	case RANGE:{
                	  tmp_ivalue = item->range;
                	  if(value.ivalue > tmp_ivalue){
                	    queue++;
                	    continue;
                	  }else{
                	    *queue_index = i;
                	    return 0;
                	  }
                	}break;
                	default:
                	  break;
                	}
                      }
                
                      if(i == real_size){
                	*queue_index = i;
                      }
                    }
                    else{//not enough, remalloc
                      tmp_queue = (sort_area_queue_t *)malloc(2 * area->allow_size * sizeof(sort_area_queue_t));
                      if(tmp_queue == NULL){
                	DEBUG("error:[%s]", "malloc err!");
                	return -1;
                      }
                      memset(tmp_queue, 0x00, 2 * area->allow_size * sizeof(sort_area_queue_t));
                      //copy old to new
                      memcpy(tmp_queue, area->cur, area->allow_size * sizeof(sort_area_queue_t));
                      if(area->allow_size != AREA_QUEUE_DEFAULT_LEN){
                      	sort_area_queue_t * ttt = area->cur;
                	free(ttt);
                      }
                      area->cur = tmp_queue;
                      area->allow_size = area->allow_size *  2;
                      *queue_index = area->real_size;
                    }
                  }
                
                  return 0;
                }
                
                //from pre_value remove prefix time value,and update relatively area
                static int remove_entity(my_market, entity, column)
                     market_t * my_market;
                     entity_t * entity;
                     column_n column;
       ##### -> {
                  int i = 0;
                  int area_index = 0;
                  int queue_index = 0;
                  sort_area_t * cur_area = NULL;
                  sort_area_queue_t * cur_queue = NULL;
                  sort_area_queue_t * after_queue = NULL;
                
                  switch(column){
                  case NEW_PRICE:{
                    area_index  = entity->price_area[0];
                    queue_index = entity->price_area[1];
                  }break;
                  case RAISE:{
                    area_index  = entity->raise_area[0];
                    queue_index = entity->raise_area[1];
                  }break;
                  case RANGE:{
                    area_index  = entity->range_area[0];
                    queue_index = entity->range_area[1];
                  }break;
                  default:
                    break;
                  }
                
                  switch(column){
                  case NEW_PRICE:{
                    cur_area = &my_market->sort_area_price[area_index];
                    if(queue_index != cur_area->real_size-1){//not last
                      i = queue_index;
                      cur_queue = cur_area->cur+i;
                      after_queue = cur_area->cur +i + 1;
                      for(; i < cur_area->real_size-1 ; i++){
                	cur_queue->entity = after_queue->entity;
                	cur_queue->entity->price_area[1] --;
                	cur_queue ++;
                	after_queue ++;
                      }
                      /*
                      after_queue = cur_area->cur + cur_area->real_size -1;
                      after_queue->index = -1;
                      after_queue->entity = NULL;
                      */
                      /*
                      cur_queue->entity->price_area[0] = -1;
                      cur_queue->entity->price_area[1] = -1;
                      cur_queue->index = -1;
                      cur_queue->entity = NULL;
                      */
                    }
                    else if(queue_index == cur_area->real_size-1){//last
                      cur_queue = cur_area->cur+cur_area->real_size-1;
                      cur_queue->entity->price_area[0] = -1;
                      cur_queue->entity->price_area[1] = -1;
                      cur_queue->index = -1;
                      cur_queue->entity = NULL;
                    }
                    cur_area->real_size --;
                  }break;
                  case RAISE:{
                    cur_area = &my_market->sort_area_raise[area_index];
                    if(queue_index != cur_area->real_size-1){//not last
                      i = queue_index;
                      cur_queue = cur_area->cur+i;
                      after_queue = cur_area->cur +i + 1;
                      for(; i < cur_area->real_size-1 ; i++){
                	cur_queue->entity = after_queue->entity;
                	cur_queue->entity->raise_area[1] --;
                	cur_queue ++;
                	after_queue ++;
                      }
                      /*
                      after_queue = cur_area->cur + cur_area->real_size -1;
                      after_queue->index = -1;
                      after_queue->entity = NULL;
                      */
                      /*
                      cur_queue->entity->price_area[0] = -1;
                      cur_queue->entity->price_area[1] = -1;
                      cur_queue->index = -1;
                      cur_queue->entity = NULL;
                      */
                    }
                    else if(queue_index == cur_area->real_size-1){//last
                      cur_queue = cur_area->cur+cur_area->real_size-1;
                      cur_queue->entity->raise_area[0] = -1;
                      cur_queue->entity->raise_area[1] = -1;
                      cur_queue->index = -1;
                      cur_queue->entity = NULL;
                    }
                    cur_area->real_size --;
                  }break;
                  case RANGE:{
                    cur_area = &my_market->sort_area_range[area_index];
                    if(queue_index != cur_area->real_size-1){//not last
                      i = queue_index;
                      cur_queue = cur_area->cur+i;
                      after_queue = cur_area->cur +i + 1;
                      for(; i < cur_area->real_size-1 ; i++){
                	cur_queue->entity = after_queue->entity;
                	cur_queue->entity->range_area[1] --;
                	cur_queue ++;
                	after_queue ++;
                      }
                      /*
                      after_queue = cur_area->cur + cur_area->real_size -1;
                      after_queue->index = -1;
                      after_queue->entity = NULL;
                      */
                      /*
                      cur_queue->entity->price_area[0] = -1;
                      cur_queue->entity->price_area[1] = -1;
                      cur_queue->index = -1;
                      cur_queue->entity = NULL;
                      */
                    }
                    else if(queue_index == cur_area->real_size-1){//last
                      cur_queue = cur_area->cur+cur_area->real_size-1;
                      cur_queue->entity->range_area[0] = -1;
                      cur_queue->entity->range_area[1] = -1;
                      cur_queue->index = -1;
                      cur_queue->entity = NULL;
                    }
                    cur_area->real_size --;
                  }break;
                  default:{
                
                  }
                  }
                
                  return 0;
                }
                
                static int sort_area(my_market, column)
                     market_t * my_market;
                     column_n column;
       ##### -> {
                  return 0;
                }
                
                int sort_get(my_market, column, index, size, entity_list)
                     market_t * my_market;
                     column_n column;
                     int index;
                     int size;
                     entity_t * entity_list;
       ##### -> {
                  sort_area_t * area = NULL;
                  int cur_real_size = 0;
                  switch(column){
                  case NEW_PRICE:
                    area = &my_market->sort_area_price;
                    break;
                  case RAISE:
                    area = &my_market->sort_area_raise;
                    break;
                  case RANGE:
                    area = &my_market->sort_area_range;
                    break;
                  default:
                    break;
                  }
                  entity_t * entity_target = &entity_list[0];
                  entity_t * entity = NULL;
                  int off      = index;
                  int off_size = size;
                  int i = 0, j = 0;
                  int entity_index = 0;
                  bool is_finish = false;
                  int begin = 1;
                  int area_count = 0;
                
                  if(entity_list == NULL){
                    DEBUG("error:[%s]", "malloc error!");
                    exit(-1);
                  }
                
                  for(i = 0; i< AREA_NUMBER; i++){
                    cur_real_size = area->real_size;
                    if(off > cur_real_size){
                      off -= cur_real_size;
                      area ++;
                      continue;
                    }else{
                      break;
                    }
                  }
                
                  begin = off;
                
                  int part_end = 0;
                  //target area and queue
                  if(area == NULL) return -1;
                  if(size > cur_real_size - begin){
                    for(j = begin; j< cur_real_size; j++){
                      entity_list[entity_index] = *(area->cur+j)->entity;
                      entity_index ++;
                      entity_target ++;
                      off_size --;
                    }
                  }else{
                    part_end = begin + size;
                    for(j = begin; j< part_end; j++){
                      entity_list[entity_index] = *(area->cur+j)->entity;
                      entity_index ++;
                      entity_target ++;
                      off_size --;
                    }
                  }
                  while(off_size >0){
                    area++;
                    area_count ++;
                    if(area == NULL) break;
                    cur_real_size = area->real_size;if(cur_real_size == 0) continue;
                    if(off_size > cur_real_size){//area all
                      for(j = 0; j< cur_real_size; j++){
                	entity_list[entity_index] = *(area->cur + j)->entity;
                	entity_target ++;
                	entity_index ++;
                	off_size --;
                      }
                    }else{//area part
                      part_end = off_size;
                      for(j = 0; j< part_end; j++){
                	entity_list[entity_index] = *(area->cur + j)->entity;
                	entity_target ++;
                	entity_index ++;
                	off_size --;
                      }
                    }
                    if(area_count > AREA_NUMBER) return -1;
                  }
                
                  return 0;
       ##### -> }


Top 10 Lines:

     Line      Count

      116        300
      344        300
       17          1

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

      601   Total number of line executions
    66.78   Average executions per line


*** File /home/jim/source_code/data-api/proxy/sort_raise_ok/main.c:
                #include<stdio.h>
                #include<stdlib.h>
                #include<unistd.h>
                #include<sys/types.h>
                #include <sys/socket.h>
                #include <netinet/in.h>
                #include <arpa/inet.h>
                #include <fcntl.h>
                #include <sys/stat.h>
                #include <assert.h>
                #include <stdbool.h>
                #include <signal.h>
                #include <pthread.h>
                #include <errno.h>
                #include "comm.h"
                #include "market.h"
                #include "./../comm_pipe.h"
                
                int last_time_market;//effective time
                int cur_time;        //current time
                int heart_times = 0;
                bool may_show_sort = false;
                app_request_t app_list[APP_SIZE] = {0};
                pthread_mutex_t work_mutex;
                pthread_mutex_t send_sort_mutex;
                pthread_cond_t allow_start_app    = PTHREAD_COND_INITIALIZER;
                pthread_cond_t allow_display_sort = PTHREAD_COND_INITIALIZER;
                
                //buff
                char * g_buff = NULL;
                #ifdef system_32
                unsigned long g_buff_max_len = 0;
                unsigned long g_buff_len = 0;
                #else
                unsigned int g_buff_max_len = 0;
                unsigned int g_buff_len = 0;
                #endif
                char * g_zib_buff = NULL;
                uLong g_zib_buff_max_len = 0;
                uLong g_zib_buff_len = 0;
                
                //simulate
                bool is_simulate = false;
                
                static void do_stock(market_t * my_market, unsigned short, char *, char *, int, option_n);
                static int send_sort(app_request_t * my_app);
                static int init_login(int socket_fd);
                
                bool is_exit = false;
                int socket_fd = 0;
                
                market_t market_list[] = {
                  //上证a股
                  {"1101.txt","20161012",0x1101,1000,"[570-690][780-900][-1--1][-1--1]"},
                  //深证a股
                  {"1201.txt","20161012",0x1201,1000,"[570-690][780-900][-1--1][-1--1]"}
                };
                
                int main()
       ##### -> {
                  pthread_t p_socket_id = 0, p_sort_id = 0, p_app_id = 0;
                  int ret = 0;
                  int test_times = 0;
                  void * recycle;
                
                #ifndef WIN32
                  sigset_t signal_mask;
                  sigemptyset(&signal_mask);
                  sigaddset(&signal_mask, SIGPIPE);
                  int rc = pthread_sigmask(SIG_BLOCK, &signal_mask, NULL);
                  if(rc != 0){
                    DEBUG("error:[%s]", "block sigpipe error!");
                  }
                #endif
                
                  //char program[1024] = {0};
                  //snprintf(program, 1023, "main_%d.prof" ,getpid());
                  //ProfilerStart(program);
                  signal(SIGINT, sig_stop);
                  //signal(SIGPIPE, sig_pipe);
                  //dynamic show sort area
                  ret = pthread_create(&p_sort_id, NULL, (void *)write_app, NULL);
                  assert( ret == 0);
                  //printf("init_sort_display ret:%d\n", ret);
                  //init app
                  ret = pthread_create(&p_app_id, NULL, (void *)init_app, NULL);
                  assert (ret == 0);
                  //printf("init app ret:%d\n", ret);
                  //--receive both shanghhai and shenzhen market stock
                  ret = init_market();
                  DEBUG("info:[ret:%d]", ret);
                  assert(ret == 0);
                  ret = init_socket(&socket_fd);
                  assert(ret == 0);
                
                  //init server's login
                  ret = init_login(socket_fd);
                  assert( ret == 0);
                
                  //init mutext
                  ret = pthread_mutex_init(&work_mutex, NULL);
                  assert( ret == 0);
                  ret = pthread_mutex_init(&send_sort_mutex, NULL);
                  assert( ret == 0);
                  if(ret != 0){
                    perror("Mutext initialization failed");
                    exit(-1);
                  }
                  ret = pthread_create(&p_socket_id, NULL, (void *)init_receive, (void *)&socket_fd);
                  assert( ret == 0);
                  //printf("init_receive ret:%d\n", ret);
                  //---init data and sort
                  //get realtime data
                  ret = send_realtime(socket_fd, 0, market_list[0].entity_list_size, 0);
                  assert(ret == 0);
                  //send_realtime(socket_fd, 0, 100, 0);
                  //---auto push data---
                  //sleep(4);
                  //get auto push data and resort data
                  //ret = send_auto_push(socket_fd, 0, market_list[0].entity_list_size, 0);
                  //assert(ret == 0);
                  //send_auto_push(socket_fd, 0, 20, 0);
                
                  int menu = 1;
                  while(true){
                    sleep(3);
                    ret = send_heart(socket_fd);
                    assert(ret == 0);
                
                    if(is_simulate){
                      ret = send_realtime(socket_fd, 0, market_list[0].entity_list_size, 0);
                      assert(ret == 0);
                      sleep(5);
                    }
                    heart_times++;
                    test_times++;
                    //if(is_exit) break;
                    // if(test_times > 1000) break;
                  }
                
                  //ProfilerStop();
                  pthread_join(p_socket_id, &recycle);
                  //pthread_join(p_sort_id, &recycle);
                  pthread_join(p_app_id, &recycle);
                  pthread_mutex_destroy(&work_mutex);
                  pthread_cond_destroy(&allow_start_app);
                  pthread_cond_destroy(&allow_display_sort);
                  DEBUG("info:[%s]", "exit system");
                  return 0;
                }
                
                int get_content(char * filename, char * buff, int buff_len)
       ##### -> {
                  int fd;
                  fd = open(filename, O_RDONLY);
                  if( fd == -1){
                    DEBUG("error:[%s]", "open err!");
                    exit(-1);
                  }
                
                  int ret = 0;
                  int length = 0;
                  while(1){
                    ret = read( fd, buff, buff_len);
                    if(ret == -1){
                      DEBUG("error:[%s]", "read err!");
                      exit(-1);
                    }
                    length += ret;
                    //   printf("buff:%s\n", buff);
                    if(ret == 0){
                      break;
                    }
                  }
                
                  close(fd);
                  return length;
                }
                
                int init_socket(int * socket_fd)
           1 -> {
                  int c_len = 0;
                  struct sockaddr_in cli;
                
                  cli.sin_family = AF_INET;
                  cli.sin_port = htons(SERVER_MARKET_PORT);
                  cli.sin_addr.s_addr = inet_addr(SERVER_MARKET);
                
                  *socket_fd = socket(AF_INET, SOCK_STREAM, 0);
                  if(*socket_fd < 0){
                    DEBUG("info:[%s]","socket() failrue!");
                    return -1;
                  }
                
                  if(connect(*socket_fd, (struct sockaddr*)&cli, sizeof(cli)) < 0){
                    DEBUG("error:[%s]", "connect() failure!");
                    return -1;
                  }
                  DEBUG("info:[%s]", "connect() success");
                  return 0;
                }
                
                //init login
                int init_login(int proxy_client_fd)
           1 -> {
                  char * package;
                  int request_len = sizeof(request_login_t);
                  int package_len = request_len ;
                  package = (char *)malloc(package_len);
                  memset(package, 0x00, package_len);
                
                  //request login
                  request_login_t * data;
                  data = (request_login_t *)package;
                  memcpy(data->header_name, HEADER, 4);
                  data->body_len = package_len - 8;
                  data->type = TYPE_LOGIN;
                
                  data->key = 3;
                  data->index = 0;
                  strncpy(data->username, USERNAME, 64);
                  strncpy(data->password, PASSWORD, 64);
                
                  write(proxy_client_fd, package, package_len);
                  free(package);
                  DEBUG("info:[%s]", "send login info!");
                
                  //response login
                  p_response_s_t  p_response_s;
                  char * buff;
                  int buff_len = 8;
                  unsigned short type;
                  assert(buff = (char *)malloc(buff_len+1));
                  memset(buff, 0x00, buff_len);
                  int n = read(proxy_client_fd, buff, buff_len);
                  DEBUG("info:[%s]", "recive login info!");
                  if(n == 8){
                    p_response_s = (p_response_s_t)buff;
                    //parse head
                    if(strncmp(p_response_s->header_name, HEADER, 4)){
                      DEBUG("error:[%s]", "recive login head of info err!");
                      exit(-1);
                    }
                    buff_len = p_response_s->body_len;
                    free(buff);
                    assert(buff = (char *)malloc(buff_len+1));
                
                    memset(buff, 0x00, buff_len+1);
                    n = read(proxy_client_fd, buff, buff_len);
                    if(n != buff_len){
                      DEBUG("error:[%s]", "recive login body's length of info err!");
                      exit(-1);
                    }
                
                    type = *((unsigned short *)buff);
                    if(type != TYPE_LOGIN){
                      DEBUG("error:[%s]", "recive login body's type of info err!");
                      exit(-1);
                    }
                
                    DEBUG("info:[%s]", "recive login info check ok!");
                    return 0;
                  }
                  else{
                    DEBUG("error:[%s]", "recive login info err!");
                    exit(-1);
                  }
                  return -1;
                }
                
                void reset_socket(int * sock_fd)
       ##### -> {
                  int ret = 0;
                  close(socket_fd);
                  ret = init_socket(socket_fd);
                  assert( ret == 0);
                  //send auto_push
                  ret = send_auto_push(socket_fd, 0, market_list[0].entity_list_size, 0);
                  assert(ret == 0);
                }
                
                int send_realtime(int socket_fd, int index, int size, int code_type_index)
           1 -> {
                  char * request;
                  int entity_count = market_list[0].entity_list_size;
                  int off = sizeof(RealPack);
                  int codeinfo_length = sizeof(CodeInfo);
                  CodeInfo * codeinfo;
                  entity_t * entity;
                  int entity_length = sizeof(entity_t);
                
                  request = (char *)malloc(sizeof(RealPack) + codeinfo_length*size);
                  if(request == NULL){
                    DEBUG("error:[%s]", "malloc err!");
                    exit(-1);
                  }
                  int request_length = sizeof(RealPack)+ codeinfo_length * size;
                
                  if(request == NULL){
                    DEBUG("error:[%s]", "malloc err!");
                    exit(-1);
                  }
                  memset(request, 0x00, sizeof(RealPack)+ codeinfo_length*size);
                
                  RealPack * data = (RealPack*)request;
                  memcpy(data->m_head, HEADER, 4);
                  data->m_length =  request_length - 8;
                  data->m_nType = TYPE_REALTIME;
                  data->m_nSize = size;
                  data->m_nOption= 0x0080;
                
                  //股票:pass
                  int i=0;
                  entity = (entity_t *)(market_list[0].list+i*entity_length);
                  for(i=index; i<(index+1)*size; i++){
                    codeinfo = (CodeInfo *)(request+off+i*codeinfo_length);
                    codeinfo->code_type = entity->type;
                    strncpy(codeinfo->code, entity->code, 6);
                    entity ++;
                  }
                
                  if(send(socket_fd, request, request_length, 0)){
                    DEBUG("info:[%s]", "send success!");
                    return 0;
                  }
                
                  return -1;
                }
                
                void init_receive(void * socket_fd)
       ##### -> {
                  char head[4];
                  char head_buff[9];
                  char * buff = NULL;
                  int package_body_length = 0;
                  int ret_count = 0;
                  int head_length = 8;
                  int length = head_length;
                  int off = 0;
                  int fd = *((int *)socket_fd);
                  int buff_len = 0;
                  int max_buff = 1;
                
                   while(1){
                     memset(&head, 0x00, 4);
                     memset(&head_buff, 0x00, 8);
                     //接受头部
                     ret_count = read(fd, head_buff, head_length);
                     //printf("fd:%d\n", fd);
                     if(ret_count == 0){
                       DEBUG("info:[%s]", "connect close!");
                       sleep(3);
                       return 0;
                     }
                     else if(ret_count <0){
                       DEBUG("error:[%s]", "recive server err!");
                	   exit(-1);
                       //reset_socket(socket_fd);
                       //sleep(3);
                       return 0;
                     }else if(ret_count == head_length){
                       off = 0;
                       //receive body of package
                       strncpy(head, head_buff, 4);
                       length = *((int *)(head_buff+4));
                       buff_len = length;
                       if(g_buff_len == 0){
                	 g_buff = (char *)malloc(length);
                	 if(g_buff == NULL){
                	   DEBUG("error:[%s]", "malloc err!");
                	   exit(-1);
                	 }
                	 memset(g_buff, 0x00, length);
                	 g_buff_len = length;
                	 g_buff_max_len = length;
                       }else{
                	 if(length > g_buff_max_len){
                	   free(g_buff);
                	   //remalloc
                	   g_buff = (char *)malloc(length);
                	   if(g_buff == NULL){
                	     DEBUG("error:[%s]", "malloc err!");
                	     exit(-1);
                	   }
                	   memset(g_buff, 0x00, length);
                	   g_buff_len = length;
                	   g_buff_max_len = length;
                	 }else{
                	   //clean
                	   memset(g_buff, 0x00, g_buff_len);
                	   g_buff_len = length;
                	 }
                       }
                       while(length != (ret_count = read(fd, g_buff+off, length))){
                	 off += ret_count;
                	 length -= ret_count;
                       }
                       //parse
                       //printf("%s\n", buff);
                       //printf("recive complete!\n");
                       parse(g_buff, buff_len);
                     }
                   }
                }
                
                void init_sort_display(void * param)
       ##### -> {
                  int i = 0, j = 0;
                  int begin = 1000;
                  int res = 0;
                  const char * fifo_name = "" ;
                  int p_id = -1;
                
                  while(1){
                    if(may_show_sort){
                      //send to app
                      for(j = 0; j < APP_SIZE; j++){
                	if(app_list[j].app_fifo_fd > 0 && app_list[j].is_create == false){
                	  //begin new pthread
                	  res = pthread_create(&p_id, NULL, write_app, (void *)&app_list[i]);
                	  assert(res == 0);
                	  app_list[j].is_create = true;
                	  continue;
                	}
                      }
                      DEBUG("info:[%s]", "display show complete");
                      sleep(2);
                    }else{
                      sleep(3);
                    }
                  }
                
                  for(j = 0; j < APP_SIZE; j++){
                    if(app_list[i].app_fifo_fd > 0){
                      close(app_list[i].app_fifo_fd);
                      app_list[i].pid = 0;
                    }
                  }
                }
                
                void init_app(void *param)
       ##### -> {
                  pthread_mutex_lock(&work_mutex);
                  pthread_cond_wait(&allow_start_app, &work_mutex);
                  pthread_mutex_unlock(&work_mutex);
                
                  int fifo_fd = -1;
                  int res = 0;
                  int i = 0;
                  int app_request_len = sizeof(app_request_t);
                  char app_request_buff[app_request_len];
                  int app_fifo_fd = 0;
                  char *template = PRIVATE_PIPE_TEMPLATE;
                  char app_fifo_name[100] = {0};
                  app_request_t * my_app = NULL, *tmp_app = NULL;
                  bool is_exists = false;
                  int ret = -1;
                
                  //open fifo
                  fifo_fd = open(PUBLIC_PIPE, O_RDWR|O_NONBLOCK);
                  if(fifo_fd == -1){
                    DEBUG("error:[%s]", "open pipe error!");
                    exit(-1);
                  }
                
                  while(true){
                    is_exists = false;
                    res = read(fifo_fd, app_request_buff, app_request_len);
                    if(res < 0){
                      if(errno == EAGAIN){
                	usleep(1000);
                	continue;
                      }
                      DEBUG("error:[%s]", "receive client app request error!");
                      exit(-1);
                      //continue;
                    }else if(res == 0){
                      continue;
                    }else{
                      //check is exists
                      tmp_app = (app_request_t*)app_request_buff;
                      DEBUG("info:[index:%d]", tmp_app->index);
                      for(i = 0; i< APP_SIZE; i++){
                	if(app_list[i].pid >0){
                	  if(kill(app_list[i].pid, 0) != 0){
                	    DEBUG("info:[close pid:%d]", app_list[i].pid);
                	    //delete pipe
                	    ret = snprintf(app_fifo_name, 100, template, app_list[i].pid);
                	    assert(res > 0);
                	    ret = unlink(app_fifo_name);
                	    DEBUG("info:[delete fifo pid:%d retL%d]", app_list[i].pid);
                	    close(app_list[i].app_fifo_fd);
                	    app_list[i].pid = 0;
                	    app_list[i].app_fifo_fd = -1;
                	    app_list[i].begin = 0;
                	    app_list[i].size  = 0;
                	    continue;
                	  }
                	}
                	if((tmp_app->pid == app_list[i].pid)
                	   && (tmp_app->option == app_list[i].option)){
                	  is_exists = true;
                	  app_list[i].begin = tmp_app->begin;
                	  app_list[i].size  = tmp_app->size;
                	  if(app_list[i].size > 10){
                		app_list[i].size = 10;
                	  }
                	  my_app = &app_list[i];
                	  res = send_sort(my_app);
                	  assert(res == 0);
                	  break;
                	}
                      }
                      if(!is_exists){
                	//not exists
                	for(i = 0; i< APP_SIZE; i++){
                	  my_app = &app_list[i];
                	  //i = i % APP_SIZE;
                	  if(my_app->pid == 0){
                	    memset(&app_fifo_name, 0x00, 100);
                	    //get
                	    *my_app = *((app_request_t*)app_request_buff);
                	    snprintf(app_fifo_name, 100, template, my_app->pid);
                	    //open fifo
                	    app_fifo_fd = open(app_fifo_name, O_WRONLY|O_NONBLOCK);
                	    if(app_fifo_fd == -1){
                	      // printf("open %s error!\n");
                	      app_list[i].pid = 0;
                	      app_list[i].app_fifo_fd = 0;
                	      app_list[i].is_create = false;
                	      break;
                	    }
                	    my_app->app_fifo_fd = app_fifo_fd;
                	    DEBUG("info[pid:%d]", my_app->pid);
                	    res = send_sort(my_app);
                	    assert(res == 0);
                	    break;
                	  }
                	}
                      }
                    }
                  }
                
                  close(fifo_fd);
                }
                
                void write_app(void *param)
       ##### -> {
                  int res = -1;
                  entity_t entity_list[SORT_SHOW_MAX_NUM];
                  market_t * my_market = NULL;
                  int i = 0;
                  app_request_t * my_app = NULL;
                  char price[10];
                
                   while(true){
                     pthread_mutex_lock(&work_mutex);
                     pthread_cond_wait(&allow_display_sort, &work_mutex);
                     for(i = 0; i < APP_SIZE; i++){
                       my_app = &app_list[i];
                       if(my_app->app_fifo_fd>0){
                	 send_sort(my_app);
                       }
                     }
                     pthread_mutex_unlock(&work_mutex);
                   }
                }
                
                static int send_sort(app_request_t * my_app)
       ##### -> {
                  int res = 0;
                  market_t * my_market = NULL;
                  //entity_t entity_list[SORT_SHOW_MAX_NUM];
                  int entity_list_size = 0;
                  int head_off = 8;
                  char t_buff[8 + sizeof(entity_t)* SORT_SHOW_MAX_NUM] = {0};
                  bool is_allow_send = true;
                  char *template = PRIVATE_PIPE_TEMPLATE;
                  int ret = 0;
                  char app_fifo_name[100] = {0};
                
                  if(pthread_mutex_trylock(&send_sort_mutex) == 0){
                    if(my_app->pid > 0){
                      if(kill(my_app->pid, 0) != 0){
                	is_allow_send = false;
                	DEBUG("info:[close pid:%d]", my_app->pid);
                	    //delete pipe
                	ret = snprintf(app_fifo_name, 100, template, my_app->pid);
                	assert(ret > 0);
                	ret = unlink(app_fifo_name);
                	DEBUG("info:[delete fifo pid:%d retL%d]", my_app->pid);
                	close(my_app->app_fifo_fd);
                	my_app->pid = 0;
                	my_app->app_fifo_fd = -1;
                	my_app->begin = 0;
                	my_app->size  = 0;
                	pthread_mutex_unlock(&send_sort_mutex);
                	return 0;
                      }
                    }
                
                    if(my_app->app_fifo_fd >0 && my_app->pid > 0){
                      //write app pipe
                      my_market = &market_list[0];
                      entity_list_size = my_market->entity_list_size;
                      //memset(&entity_list, 0x00, SORT_SHOW_MAX_NUM * sizeof(entity_t));
                      if(my_app->begin < entity_list_size
                	 && my_app->begin + my_app->size < entity_list_size){
                	res = sort_get(my_market,
                		       my_app->column,
                		       my_app->begin,
                		       my_app->size,
                		       t_buff + head_off);
                      }else if(my_app->begin < entity_list_size){
                	res = sort_get(my_market,
                		       my_app->column,
                		       my_app->begin,
                		       entity_list_size - my_app->begin,
                		       t_buff + head_off);
                      }
                      assert(res == 0);
                      memcpy(t_buff, &my_app->option, 4);
                      memcpy(t_buff+4, &my_app->begin, 4);
                      //memcpy(t_buff+4, &entity_list, my_app->size*sizeof(entity_t));
                      res = write(my_app->app_fifo_fd, &t_buff, my_app->size*sizeof(entity_t)+head_off);
                      if(res == -1){
                	DEBUG("error:[%s]", "write app fifo err!");
                	//close pipe
                	close(my_app->app_fifo_fd);
                	my_app->app_fifo_fd = 0;
                	my_app->pid = 0;
                	my_app->begin = 0;
                	my_app->size = 0;
                	my_app->is_create = false;
                      }
                    }
                    pthread_mutex_unlock(&send_sort_mutex);
                  }
                  return 0;
                }
                
                int send_auto_push(int socket_fd, int index, int size, int code_type_index)
           1 -> {
                  char * request;
                  int off = sizeof(RealPack_ex);
                  int codeinfo_length = sizeof(CodeInfo);
                  CodeInfo * codeinfo;
                  entity_t * entity;
                  int entity_length = sizeof(entity_t);
                  int i = 0;
                  int request_length = sizeof(RealPack_ex)+codeinfo_length*size;
                
                  assert(jim_malloc(request_length, &request) == 0);
                
                  RealPack_ex * data = (RealPack_ex *)request;
                  memcpy(data->m_head,HEADER,4);
                  data->m_length =  request_length-8;
                  data->m_nType = TYPE_AUTO_PUSH;
                  data->m_nSize = size;
                  data->m_nOption= 0x0080;
                
                  entity = (entity_t *)(market_list[code_type_index].list+i*entity_length);
                  for(i = index; i<(index+1)*size; i++){
                    codeinfo = (CodeInfo *)(request + off + i * codeinfo_length);
                    codeinfo->code_type = entity->type;
                    strncpy(codeinfo->code, entity->code, 6);
                    entity ++;
                  }
                
                  if(send(socket_fd, request, request_length, 0)){
                    //printf("send auto_push success!\n");
                    return 0;
                  }
                
                  return -1;
                }
                
                int send_heart(int socket_fd)
           2 -> {
                  char request[1024];
                  TestSrvData2 data ;
                  memset(&data,0x00,sizeof(TestSrvData2));
                  memcpy(data.head, HEADER,4);
                  data .length      = sizeof(TestSrvData2) -8;
                  data.m_nType     = TYPE_HEART;
                  data.m_nIndex= 1;
                
                  memset(request, 0, 1024);
                  memcpy(request, &data, sizeof(data));
                  send(socket_fd, request, sizeof(data), 0);
                  //printf("send heart message...\n");
                  return 0;
                }
                int option_times = 0;
                int parse(char * buff, uLongf  buff_len)
           3 -> {
                  unsigned short type;
                  int res = -1;
                
                  if(buff == NULL)
                    return -2;
                  type = (*(unsigned short *)buff);
                  //printf("type:%02x\n", type);
                  switch(type){
                  case TYPE_REALTIME:{
                    //printf("realtime...\n");
                    res = parse_realtime(buff, buff_len);
                    assert( res == 0);
                    //may display sort
                    if(!is_simulate){
                      pthread_mutex_lock(&work_mutex);
                      pthread_cond_signal(&allow_start_app);
                      pthread_mutex_unlock(&work_mutex);
                    }
                    //sort
                    column_n sort_column = NEW_PRICE;
                    //is_exit = true;
                    if(is_simulate){
                      pthread_mutex_lock(&work_mutex);
                      pthread_cond_signal(&allow_display_sort);
                      pthread_mutex_unlock(&work_mutex);
                    }
                    option_times ++;
                    DEBUG("info:[option_times:%d]", option_times);
                    sleep(3);
                    // is_simulate = true;
                    res = send_auto_push(socket_fd, 0, market_list[0].entity_list_size, 0);
                    assert(res == 0);
                  }break;
                  case TYPE_AUTO_PUSH:{
                    //printf("recieve auto_push...\n");
                    res = parse_auto_push(buff, buff_len);
                    assert( res == 0);
                    pthread_mutex_lock(&work_mutex);
                    pthread_cond_signal(&allow_display_sort);
                    pthread_mutex_unlock(&work_mutex);
                    option_times ++;
                    DEBUG("info:[option_times:%d]", option_times);
                  }break;
                  case TYPE_HEART:{
                    //printf("heart...\n");
                    heart_times--;
                  }break;
                  case TYPE_ZIB:{
                    //printf("bzib...\n");
                    res = unpack(buff, buff_len);
                    assert( res == 0);
                    res = parse(g_zib_buff, g_zib_buff_len);
                    assert( res == 0);
                  }break;
                  default:{
                    DEBUG("info:[unknown type:%d]", type);
                  }break;
                  }
                  return 0;
                }
                
                int parse_realtime(char * buff, uLongf buff_len)
           1 -> {
                  AskData2 * data_head = (AskData2 *)(buff);
                  char code[7]={0};
                  int i= 0;
                  int index = 0;
                  market_t * my_market = NULL;
                  int code_len = 0;
                
                  for(i=0; i< data_head->m_nSize; i++){
                    memset(&code, 0x00, 7);
                    CommRealTimeData * data_type = (CommRealTimeData *)(buff
                							+ 20
                							+ i*(sizeof(CommRealTimeData)+sizeof(HSStockRealTime)));
                    //code_len = strlen(data_type->m_cCode);
                    strncpy(code, data_type->m_cCode, 6);
                    code[6] = '\0';
                    //printf("code:%s\n", code);
                    switch(data_type->m_cCodeType){
                    case 0x1101:{
                      my_market = &market_list[index];
                      do_stock(my_market, data_type->m_cCodeType, code, buff, i, ADD);
                    }break;
                    case 0x1201:{
                      my_market = &market_list[index];
                      do_stock(my_market, data_type->m_cCodeType, code, buff, i, ADD);
                    }break;
                    case 0x1206:{
                      my_market = &market_list[index];
                      do_stock(my_market, data_type->m_cCodeType, code, buff, i, ADD);
                    }break;
                    case 0x120b:{
                      my_market = &market_list[index];
                      do_stock(my_market, data_type->m_cCodeType, code, buff, i, ADD);
                    }break;
                    }
                  }
                  return 0;
                }
                
                //处理股票
                static void
                do_stock(my_market, code_type, code, buff, i, option)
                     market_t * my_market;
                     unsigned short code_type;
                     char * code;
                     char * buff;
                     int i;
                     option_n option;
         100 -> {
                  void * address = NULL;
                  unsigned int code_type_index = 0;
                  entity_t * entity;
                  // column_n column = NEW_PRICE;
                  switch(code_type){
                  case 0x110:{
                    code_type_index = 0;
                  }break;
                  case 0x1201:{
                    code_type_index = 1;
                  }break;
                  case 0x1206:{
                    code_type_index = 2;
                  }break;
                  case 0x120b:{
                    code_type_index = 3;
                  }break;
                  }
                  address = find_entity_by_key(code, 6, code_type_index);
                  assert(address != NULL);
                  entity = (entity_t *)address;
                
                  HSStockRealTime * tmp = (HSStockRealTime *)(buff
                					      +20
                					      +sizeof(CommRealTimeData)
                					      +i*(sizeof(CommRealTimeData)+sizeof(HSStockRealTime)));
                
                  entity->price       = tmp->m_lNewPrice;
                  if(entity->price == 0){
                    entity->raise = 0;
                    entity->range = 0;
                  }
                  else{
                    entity->raise  = entity->price - entity->pre_close;
                    entity->range  = round(entity->raise *10000.0 / entity->pre_close);
                  }
                  entity->max         = tmp->m_lMaxPrice;
                  entity->min         = tmp->m_lMinPrice;
                  entity->total       = tmp->m_lTotal;
                  entity->money       = tmp->m_fAvgPrice;
                  DEBUG("info:[index:%d,code_type:%2x,code:%s,pre_close:%d,new_price:%d,raise:%d,range:%d]",i, code_type, code, entity->pre_close, entity->price, entity->raise, entity->range);
                  if(is_simulate){
                    srand(time(0));
                    entity->price = tmp->m_lNewPrice + (rand()%10);
                    option = UPDATE;
                  }
                  switch(option){
                  case ADD:{
                    //add to sort
                    sort_add(my_market, entity, NEW_PRICE);
                    sort_add(my_market, entity, RAISE);
                    sort_add(my_market, entity, RANGE);
                  }break;
                  case UPDATE:{
                    //update
                    sort_update(my_market, entity, NEW_PRICE);
                    sort_update(my_market, entity, RAISE);
                    sort_update(my_market, entity, RANGE);
                  }break;
                  default:{
                
                  }
                  }
                }
                
                int parse_auto_push(char * buff, uLong   buff_len)
       ##### -> {
                  //printf("parse auto_push...\n");
                  AskData2 * data_head = (AskData2 *)(buff);
                  char code[7]={0};
                  int i = 0;
                  int index = 0;
                  market_t * my_market = NULL;
                
                  for(i=0; i< data_head->m_nSize; i++){
                    CommRealTimeData * data_type = (CommRealTimeData *)(buff
                							+ 20
                							+ i*(sizeof(CommRealTimeData)+sizeof(HSStockRealTime)));
                    memcpy(code, data_type->m_cCode, 6);
                    switch(data_type->m_cCodeType){
                    case 0x1101:{
                      my_market = &market_list[index];
                      //printf("code_type:%2x, code:%s\n", data_type->m_cCodeType, code);
                      do_stock(my_market, data_type->m_cCodeType, code, buff, i, UPDATE);
                    }
                    case 0x1201:{
                      my_market = &market_list[index];
                      //printf("code_type:%2x, code:%s\n", data_type->m_cCodeType, code);
                      do_stock(my_market, data_type->m_cCodeType, code, buff, i, UPDATE);
                    }
                    case 0x1206:{
                      my_market = &market_list[index];
                      //printf("code_type:%2x, code:%s\n", data_type->m_cCodeType, code);
                      do_stock(my_market, data_type->m_cCodeType, code, buff, i, UPDATE);
                    }
                    case 0x120b:{
                      my_market = &market_list[index];
                      //printf("code_type:%2x, code:%s\n", data_type->m_cCodeType, code);
                      do_stock(my_market, data_type->m_cCodeType, code, buff, i, UPDATE);
                    }
                  }
                  }
                
                  return 0;
                }
                
                int unpack(char * des_buff, uLongf des_buff_len)
           1 -> {
                  uLong src_length = 0;
                  TransZipData2   * zheader;
                  zheader = (TransZipData2 *)des_buff;
                  if(zheader->m_nType != TYPE_ZIB){
                    DEBUG("error:[%s]", "parse zlib package type error!");
                    return -100;
                  }
                
                  src_length = (uLongf)zheader->m_lOrigLen;
                  if(g_zib_buff_len == 0){
                    g_zib_buff_len = src_length;
                    g_zib_buff_max_len= src_length;
                    g_zib_buff = (char *)malloc(g_zib_buff_len);
                    assert(g_zib_buff != NULL);
                    if(g_zib_buff == NULL){
                      DEBUG("error:[%s]", "malloc err!");
                      return -1;
                    }
                    memset(g_zib_buff, 0x00, g_zib_buff_len);
                  }else{
                    if(src_length > g_zib_buff_max_len){//remalloc
                      free(g_zib_buff);
                      g_zib_buff_len = src_length;
                      g_zib_buff_max_len = src_length;
                      g_zib_buff = (char *)malloc(g_zib_buff_len);
                      assert(g_zib_buff != NULL);
                      if(g_zib_buff == NULL){
                	DEBUG("error:[%s]", "malloc err!");
                	return -1;
                      }
                      memset(g_zib_buff, 0x00, g_zib_buff_len);
                    }else{//clean
                      memset(g_zib_buff, 0x00, g_zib_buff_len);
                      g_zib_buff_len = src_length;
                    }
                  }
                
                
                  int unzip =  uncompress((Bytef *)(g_zib_buff), &g_zib_buff_len,
                			  (Bytef*)zheader->m_cData, (uLongf)zheader->m_lZipLen);
                  if(unzip == Z_MEM_ERROR){
                    DEBUG("error:[%s]", "memory not enough");
                    return -2;
                  }
                  if(unzip == Z_BUF_ERROR){
                    DEBUG("error:[%s]", "buff not enough!");
                    return -3;
                  }
                  if(unzip == Z_DATA_ERROR){
                    DEBUG("error:[%s]", "unpack data err!");
                    return -4;
                   }
                  if(unzip == Z_OK
                     && g_zib_buff_len == zheader->m_lOrigLen){
                    DEBUG("info:[%s]", "unpack success!");
                    return 0;
                  }
                  DEBUG("info:[unzip:%d]", unzip);
                  return -1;
                }
                
                int get_index_by_code_ascii(char ascii)
        1200 -> {
                  int base_digit = 0;
                  int base_alphabet = 10;
                  //digit
                  if(ascii>=48 || ascii <=57){
                    return base_digit+ascii-48;
                  }
                
                  //alphabet
                  if(ascii>=65 || ascii <= 80){
                    return base_alphabet+ascii-65;
                  }
                
                  return -1;
                }
                
                void sig_stop(int signo)
       ##### -> {
                  DEBUG("info:[%s]", "abovt exit!");
                  shutdown(socket_fd, SHUT_RDWR);
                  //close(socket_fd);
                  exit(-1);
                }
                
       ##### -> void sig_pipe(int signo){
       ##### -> }


Top 10 Lines:

     Line      Count

      978       1200
      807        100
      696          3
      679          2
      181          1
      205          1
      283          1
      643          1
      759          1
      915          1

Execution Summary:

       22   Executable lines in this file
       22   Lines executed
   100.00   Percent of the file executed

     1311   Total number of line executions
    59.59   Average executions per line
